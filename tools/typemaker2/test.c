/**********************************************************
 * This file has been automatically created by "typemaker2"
 * from the file "test.xml".
 * Please do not edit this file, all changes will be lost.
 * Better edit the mentioned source file instead.
 **********************************************************/

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif

#include "test_p.h"

#include <gwenhywfar/misc.h>
#include <gwenhywfar/debug.h>

/* code headers */

/* macro functions */
GWEN_LIST_FUNCTIONS(TEST, Test)
GWEN_LIST2_FUNCTIONS(TEST, Test)
GWEN_INHERIT_FUNCTIONS(TEST)
GWEN_IDMAP_FUNCTIONS(TEST, Test)


TEST *Test_new() {
  TEST *p_struct;

  GWEN_NEW_OBJECT(TEST, p_struct)
  GWEN_INHERIT_INIT(TEST, p_struct)
  GWEN_LIST_INIT(TEST, p_struct)
  /* members */
  p_struct->id=0;
  p_struct->charPointer=NULL;
  memset(p_struct->charArray, 0, 32);
  p_struct->charPointerNoDup=NULL;
  p_struct->charPointerPrivate=NULL;

  return p_struct;
}

void Test_free(TEST *p_struct) {
  if (p_struct) {
    GWEN_INHERIT_FINI(TEST, p_struct)
    GWEN_LIST_FINI(TEST, p_struct)
  /* members */
    
    free(p_struct->charPointer);
    
    free(p_struct->charPointerNoDup);
    free(p_struct->charPointerPrivate);
    GWEN_FREE_OBJECT(p_struct);
  }
}

TEST *Test_dup(const TEST *p_src) {
  TEST *p_struct;

  assert(p_src);
  p_struct=Test_new();
  /* member "id" */
  p_struct->id=p_src->id;

  /* member "charPointer" */
  if (p_struct->charPointer) {
    free(p_struct->charPointer);
    p_struct->charPointer=NULL;
  }
  if (p_src->charPointer) {
    p_struct->charPointer=strdup(p_src->charPointer);
  }

  /* member "charArray" */
  strncpy(p_struct->charArray, p_src->charArray, 32-1); (p_struct->charArray)[32-1]=0;

  /* member "charPointerNoDup" has nodup flag, not copying */

  /* member "charPointerPrivate" */
  if (p_struct->charPointerPrivate) {
    free(p_struct->charPointerPrivate);
    p_struct->charPointerPrivate=NULL;
  }
  if (p_src->charPointerPrivate) {
    p_struct->charPointerPrivate=strdup(p_src->charPointerPrivate);
  }

  return p_struct;
}

uint32_t Test_GetId(const TEST *p_struct) {
  assert(p_struct);
  return p_struct->id;
}

const char *Test_GetCharPointer(const TEST *p_struct) {
  assert(p_struct);
  return p_struct->charPointer;
}

const char *Test_GetCharArray(const TEST *p_struct) {
  assert(p_struct);
  return p_struct->charArray;
}

const char *Test_GetCharPointerNoDup(const TEST *p_struct) {
  assert(p_struct);
  return p_struct->charPointerNoDup;
}

const char *Test_GetCharPointerPrivate(const TEST *p_struct) {
  assert(p_struct);
  return p_struct->charPointerPrivate;
}

void Test_SetId(TEST *p_struct, uint32_t p_src) {
  assert(p_struct);
    p_struct->id=p_src;
}

void Test_SetCharPointer(TEST *p_struct, const char *p_src) {
  assert(p_struct);
  if (p_struct->charPointer) {
    free(p_struct->charPointer);
}
  if (p_src) {
    p_struct->charPointer=strdup(p_src);
  }
  else {
    p_struct->charPointer=NULL;
  }
}

void Test_SetCharArray(TEST *p_struct, const char *p_src) {
  assert(p_struct);
    strncpy(p_struct->charArray, p_src, 32-1); (p_struct->charArray)[32-1]=0;
}

void Test_SetCharPointerNoDup(TEST *p_struct, const char *p_src) {
  assert(p_struct);
  if (p_struct->charPointerNoDup) {
    free(p_struct->charPointerNoDup);
}
  if (p_src) {
    p_struct->charPointerNoDup=strdup(p_src);
  }
  else {
    p_struct->charPointerNoDup=NULL;
  }
}

void Test_SetCharPointerPrivate(TEST *p_struct, const char *p_src) {
  assert(p_struct);
  if (p_struct->charPointerPrivate) {
    free(p_struct->charPointerPrivate);
}
  if (p_src) {
    p_struct->charPointerPrivate=strdup(p_src);
  }
  else {
    p_struct->charPointerPrivate=NULL;
  }
}

void Test_ReadDb(TEST *p_struct, GWEN_DB_NODE *p_db) {
  assert(p_struct);
  /* member "id" */
  p_struct->id=0;
  /* member "id" is volatile, not reading from db */

  /* member "charPointer" */
  if (p_struct->charPointer) {
    free(p_struct->charPointer);
  }
  p_struct->charPointer=NULL;
  { const char *s; s=GWEN_DB_GetCharValue(p_db, "charPointer", 0, NULL); if (s) p_struct->charPointer=strdup(s); }

  /* member "charArray" */
  memset(p_struct->charArray, 0, 32);
  { const char *s; s=GWEN_DB_GetCharValue(p_db, "charArray", 0, NULL); if (s) strncpy(p_struct->charArray, s, 32); }

  /* member "charPointerNoDup" */
  if (p_struct->charPointerNoDup) {
    free(p_struct->charPointerNoDup);
  }
  p_struct->charPointerNoDup=NULL;
  { const char *s; s=GWEN_DB_GetCharValue(p_db, "charPointerNoDup", 0, NULL); if (s) p_struct->charPointerNoDup=strdup(s); }

  /* member "charPointerPrivate" */
  if (p_struct->charPointerPrivate) {
    free(p_struct->charPointerPrivate);
  }
  p_struct->charPointerPrivate=NULL;
  { const char *s; s=GWEN_DB_GetCharValue(p_db, "charPointerPrivate", 0, NULL); if (s) p_struct->charPointerPrivate=strdup(s); }

}

int Test_WriteDb(const TEST *p_struct, GWEN_DB_NODE *p_db) {
  int p_rv;

  assert(p_struct);
  /* member "id" is volatile, not writing to db */

  /* member "charPointer" */
  if (p_struct->charPointer) { p_rv=GWEN_DB_SetCharValue(p_db, GWEN_DB_FLAGS_OVERWRITE_VARS, "charPointer", p_struct->charPointer); } else { GWEN_DB_DeleteVar(p_db, "charPointer"); p_rv=0; }
  if (p_rv<0) {
    DBG_INFO(GWEN_LOGDOMAIN, "here (%d)\n", p_rv);
    return p_rv;
  }

  /* member "charArray" */
  if (*(p_struct->charArray)) { p_rv=GWEN_DB_SetCharValue(p_db, GWEN_DB_FLAGS_OVERWRITE_VARS, "charArray", p_struct->charArray); } else { GWEN_DB_DeleteVar(p_db, "charArray"); p_rv=0; }
  if (p_rv<0) {
    DBG_INFO(GWEN_LOGDOMAIN, "here (%d)\n", p_rv);
    return p_rv;
  }

  /* member "charPointerNoDup" */
  if (p_struct->charPointerNoDup) { p_rv=GWEN_DB_SetCharValue(p_db, GWEN_DB_FLAGS_OVERWRITE_VARS, "charPointerNoDup", p_struct->charPointerNoDup); } else { GWEN_DB_DeleteVar(p_db, "charPointerNoDup"); p_rv=0; }
  if (p_rv<0) {
    DBG_INFO(GWEN_LOGDOMAIN, "here (%d)\n", p_rv);
    return p_rv;
  }

  /* member "charPointerPrivate" */
  if (p_struct->charPointerPrivate) { p_rv=GWEN_DB_SetCharValue(p_db, GWEN_DB_FLAGS_OVERWRITE_VARS, "charPointerPrivate", p_struct->charPointerPrivate); } else { GWEN_DB_DeleteVar(p_db, "charPointerPrivate"); p_rv=0; }
  if (p_rv<0) {
    DBG_INFO(GWEN_LOGDOMAIN, "here (%d)\n", p_rv);
    return p_rv;
  }

  return 0;
}

TEST *Test_fromDb(GWEN_DB_NODE *p_db) {
  TEST *p_struct;
  p_struct=Test_new();
  Test_ReadDb(p_struct, p_db);
  return p_struct;
}

int Test_toDb(const TEST *p_struct, GWEN_DB_NODE *p_db) {
  return Test_WriteDb(p_struct, p_db);
}

void Test_ReadXml(TEST *p_struct, GWEN_XMLNODE *p_db) {
  assert(p_struct);
  /* member "id" */
  p_struct->id=0;
  /* member "id" is volatile, not reading from xml */

  /* member "charPointer" */
  if (p_struct->charPointer) {
    free(p_struct->charPointer);
  }
  p_struct->charPointer=NULL;
  { const char *s; s=GWEN_XMLNode_GetCharValue(p_db, "charPointer", NULL); if (s) p_struct->charPointer=strdup(s); }

  /* member "charArray" */
  memset(p_struct->charArray, 0, 32);
  { const char *s; s=GWEN_XMLNode_GetCharValue(p_db, "charArray", NULL); if (s) strncpy(p_struct->charArray, s, 32); }

  /* member "charPointerNoDup" */
  if (p_struct->charPointerNoDup) {
    free(p_struct->charPointerNoDup);
  }
  p_struct->charPointerNoDup=NULL;
  { const char *s; s=GWEN_XMLNode_GetCharValue(p_db, "charPointerNoDup", NULL); if (s) p_struct->charPointerNoDup=strdup(s); }

  /* member "charPointerPrivate" */
  if (p_struct->charPointerPrivate) {
    free(p_struct->charPointerPrivate);
  }
  p_struct->charPointerPrivate=NULL;
  { const char *s; s=GWEN_XMLNode_GetCharValue(p_db, "charPointerPrivate", NULL); if (s) p_struct->charPointerPrivate=strdup(s); }

}

void Test_WriteXml(const TEST *p_struct, GWEN_XMLNODE *p_db) {
  assert(p_struct);
  /* member "id" is volatile, not writing to xml */

  /* member "charPointer" */
  if (p_struct->charPointer) { GWEN_XMLNode_SetCharValue(p_db, "charPointer", p_struct->charPointer); } else { /* TODO: remove element */ }

  /* member "charArray" */
  if (*(p_struct->charArray)) { GWEN_XMLNode_SetCharValue(p_db, "charArray", p_struct->charArray); } else { /* TODO: need to reset this variable */ }

  /* member "charPointerNoDup" */
  if (p_struct->charPointerNoDup) { GWEN_XMLNode_SetCharValue(p_db, "charPointerNoDup", p_struct->charPointerNoDup); } else { /* TODO: remove element */ }

  /* member "charPointerPrivate" */
  if (p_struct->charPointerPrivate) { GWEN_XMLNode_SetCharValue(p_db, "charPointerPrivate", p_struct->charPointerPrivate); } else { /* TODO: remove element */ }

}

void Test_toXml(const TEST *p_struct, GWEN_XMLNODE *p_db) {
  Test_WriteXml(p_struct, p_db);
}

TEST *Test_fromXml(GWEN_XMLNODE *p_db) {
  TEST *p_struct;
  p_struct=Test_new();
  Test_ReadXml(p_struct, p_db);
  return p_struct;
}

